import json
import time
from google import genai
from google.genai import types
import argparse
import re
from collections import defaultdict
import os
from tqdm import tqdm
from dotenv import load_dotenv

load_dotenv()

api_key = os.getenv("GEMINI_API_KEY")

if not api_key:
    raise ValueError("API key not found. Please set it in your environment variables.")

client = genai.Client(api_key=api_key)

def extract_with_llm(response_text, max_retries=3):
    system_prompt = "You are a helpful assistant. Extract only the final answer choice (A, B, C, D). Respond only with the letter."
    user_prompt = f"""
You are given a response generated by a language model for a multiple-choice question. The question may involve math, science, or common-sense reasoning. The response may include reasoning steps and mention multiple answer options.

Your task is to extract and return only the last explicitly stated answer option letter from the response. Valid answer options are A, B, C, D.

- Focus on the final stated answer the model arrives at, even if earlier options are mentioned.
- Your output must be a single capital letter.

Examples:

• "The answer is (B). But after recalculating, we find the correct answer is (C)."  
→ C

• "After solving, the correct answer is (A) apple."  
→ A

Now, extract the last mentioned answer option letter from the following response:
{response_text}
"""
    for attempt in range(max_retries):
        try:
            response = client.models.generate_content(
                model="gemini-2.0-flash",
                config=types.GenerateContentConfig(
                    system_instruction=system_prompt
                ),
                contents=user_prompt
            )
            content = response.text.strip().upper()
            if re.match(r"^[A-D]$", content):
                return content
            
        except Exception as e:
            print(f"[Retry {attempt+1}] Error: {e}")
            time.sleep(3)
    return None

def eval_file(pred_file):
    print(f"Evaluating {pred_file}...")

    with open(pred_file, 'r', encoding='utf-8') as f:
        inference_responses = [json.loads(line) for line in f]

    stats = {"correct": 0, "total": 0, "degenerate": 0}

    for item in tqdm(inference_responses):
        stats["total"] += 1
        gt = item["answer"]
        raw_response = item["prediction"]

        response = raw_response.strip()

        pred = extract_with_llm(response)
        item["predicted_answer"] = pred
        item["correct"] = (pred == gt)
        
        if pred == gt:
            stats["correct"] += 1
        if pred is None:
            print(f"Failed to extract answer for item: {item['id']}")
            continue
        # print(f"ID: {item['id']}, GT: {gt}, Pred: {pred}, Response: {response[-10:]}")
    
    print(f"Total: {stats['total']}, Correct: {stats['correct']}, Accuracy: {stats['correct'] / stats['total']:.4f}")
    
    output_file = pred_file.replace('.jsonl', '_scored.jsonl')
    with open(output_file, 'w', encoding='utf-8') as f:
        for item in inference_responses:
            f.write(json.dumps(item, ensure_ascii=False) + '\n')
    return stats

def arg_parser():
    parser = argparse.ArgumentParser()
    parser.add_argument("--pred_file", default=None, help="jsonl format")
    parser.add_argument("--pred_dir", default=None, help="Directory containing prediction files")
    return parser.parse_args()

def main():
    args = arg_parser()
    if args.pred_file is None and args.pred_dir is None:
        raise ValueError("Please provide either --pred_file or --pred_dir.")
    
    if args.pred_file is not None and args.pred_dir is not None:
        raise ValueError("Please provide only one of --pred_file or --pred_dir.")
    
    if args.pred_file is not None:
        eval_file(args.pred_file)
    else:
        if not os.path.isdir(args.pred_dir):
            raise ValueError(f"Directory {args.pred_dir} does not exist.")
        
        for filename in os.listdir(args.pred_dir):
            if filename.endswith(".jsonl"):
                pred_file = os.path.join(args.pred_dir, filename)
                eval_file(pred_file)
                
    
    
    
        

if __name__ == "__main__":
    main()
